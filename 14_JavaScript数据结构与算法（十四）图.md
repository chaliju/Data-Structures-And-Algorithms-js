# JavaScript 数据结构与算法（十四）图

## 图的概念

在计算机程序设计中，图也是一种非常常见的数据结构，图论其实是一个非常大的话题，在数学上起源于哥尼斯堡七桥问题。

### 什么是图？

- 图是一种与树有些相似的数据结构。

  - 实际上，在数学的概念上，树是图的一种。
  - 我们知道树可以用来模拟很多现实的数据结构，比如：家谱/公司组织架构等等。

- 那么图长什么样子呢？或者什么样的数据使用图来模拟更合适呢？

  - 人与人之间的关系网（六度空间理论）
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4cdhxz0ereu0.png)

  - 互联网中的网络关系
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.4ljxyy69a1s0.png)

  - 广州地铁图
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.46k2cvwmthw0.png)

- 那么，什么是图呢?

  - 我们会发现，上面的结点（其实图中叫顶点 Vertex）之间的关系，是不能使用树来表示（几叉树都不可以）。
  - 这个时候，我们就可以使用**图**来模拟它们。

- 图通常有什么特点呢？
  - **一组顶点**：通常用 V (Vertex) 表示顶点的集合
  - **一组边**：通常用 E (Edge) 表示边的集合
  - 边是顶点和顶点之间的连线
  - 边可以是有向的，也可以是无向的。（比如 A --- B，通常表示无向。 A --> B，通常表示有向）

### 图的术语

#### 术语

- 我们在学习树的时候，树有很多的其他术语，了解这些术语有助于我们更深层次的理解图。
- 但是图的术语其实非常多，如果你找一本专门讲图的各个方面的书籍，会发现只是术语就可以占据一个章节。
- 这里，这里介绍几个比较常见的术语，某些术语后面用到的时候，再了解，没有用到的，不做赘述。
- 下面这是个抽象出来的图
  ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.rr153grdbc0.png)

- **顶点**
  - 顶点刚才我们已经介绍过了，表示**图中的一个结点**。
  - 比如地铁站中某个站/多个村庄中的某个村庄/互联网中的某台主机/人际关系中的人。
  
- **边**
  - 边表示**顶点和顶点之间的连线**。
  - 比如地铁站中两个站点之间的直接连线, 就是一个边。
  - 注意：这里的边不要叫做路径，路径有其他的概念，后面会区分。
  
- **相邻顶点**
  - 由**一条边连接在一起的顶点**称为相邻顶点。
  - 比如 `0 - 1` 是相邻的，`0 - 3` 是相邻的。`0 - 2` 是不相邻的。
  
- **度**
  - 一个顶点的度是**相邻顶点的数量**
  - 比如 0 顶点和其他两个顶点相连，0 顶点的度是 2
  - 比如 1 顶点和其他四个顶点相连，1 顶点的度是 4
  
- **路径**
  - 路径是顶点 `v1`，`v2`...，`vn` 的一个连续序列, 比如上图中 `0 1 5 9` 就是一条路径。
  - **简单路径:** 简单路径要求**不包含重复的顶点**。比如 `0 1 5 9` 是一条简单路径。
  - **回路：****第一个顶点和最后一个顶点相同**的路径称为回路。比如 `0 1 5 6 3 0`。
  
- **无向图**
  - 上面的图就是一张无向图，因为**所有的边都没有方向**。
  - 比如 `0 - 1` 之间有变，那么说明这条边可以保证 `0 -> 1`，也可以保证 `1 -> 0`。
  
- **有向图**
  - 有向图表示的**图中的边是有方向的**。
  - 比如 `0 -> 1`，不能保证一定可以 `1 -> 0`，要根据方向来定。

#### 无权图和带权图

- **无权图**
  - 我们上面的图就是一张**无权图（边没有携带权重）**
  - 我们上面的图中的边是没有任何意义的，不能收 `0 - 1` 的边，比 `4 - 9` 的边更远或者用的时间更长。
  
- **带权图**
  - **带权图表示边有一定的权重**
  - 这里的权重可以是任意你希望表示的数据：比如距离或者花费的时间或者票价。
  - 我们来看一张有向和带权的图
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3q0nj5eq5p80.png)

### 现实建模

- 对交通流量建模

  - 顶点可以表示街道的十字路口，边可以表示街道.。
  - 加权的边可以表示限速或者车道的数量或者街道的距离。
  - 建模人员可以用这个系统来判定最佳路线以及最可能堵车的街道。

- 对飞机航线建模

  - 航空公司可以用图来为其飞行系统建模。
  - 将每个机场看成顶点，将经过两个顶点的每条航线看作一条边。
  - 加权的边可以表示从一个机场到另一个机场的航班成本，或两个机场间的距离。
  - 建模人员可以利用这个系统有效的判断从一个城市到另一个城市的最小航行成本。
    ​

## 图的表示

我们知道一个图包含很多顶点，另外包含顶点和顶点之间的连线（边），这两个都是非常重要的图信息，因此都需要在程序中体现出来。

### 顶点表示

- 顶点的表示相对简单

  - 上面的顶点，我们抽象成了 1 2 3 4，也可以抽象成 A B C D。在后面的案例中，我们使用 A B C D。
  - 那么这些 A B C D 我们可以使用一个数组来存储起来(存储所有的顶点)。
  - 当然，A B C D 有可能还表示其他含义的数据(比如村庄的名字)，这个时候，可以另外创建一个数组，用于存储对应的其他数据。

- 边的表示略微复杂
  - 因为边是两个顶点之间的关系，所以表示起来会稍微麻烦一些。
  - 下面是变常见的表示方式。

### 邻接矩阵

- 概述

  - 邻接矩阵让**每个节点和一个整数向关联**, 该**整数作为数组的下标值**。
  - 我们用一个**二维数组**来表示**顶点之间的连接**。
  - 演示
    ![image-20200303213913574](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/1.png)

- 图片解析

  - 在二维数组中，**0 表示没有连线，1 表示有连线**。
  - 通过二维数组，我们可以很快的找到**一个顶点和哪些顶点有连线**。（比如 A 顶点, 只需要 遍历第一行即可）
  - 另外，A - A，B - B（也就是顶点到自己的连线），通常使用 0 表示。

- **邻接矩阵的问题**
  - 如果是一个无向图，邻接矩阵展示出来的二维数组，其实是一个对称图。
  
    - 也就是 A -> D 是 1 的时候，对称的位置 D -> 1 一定也是 1。
    - 那么这种情况下会造成空间的浪费，解决办法需自己去研究下。
  
  - 邻接矩阵还有一个比较严重的问题就是如果图是一个**稀疏图**
    - 那么矩阵中将**存在大量的 0**，这意味着我们浪费了计算机存储空间来表示根本不存在的边。
    - 而且即使只有一个边，我们也必须遍历一行来找出这个边，也浪费很多时间。

### 邻接表

- 概述

  - 邻接表由图中**每个顶点以及和顶点相邻的顶点列表**组成。
  - 这个列表有很多中方式来存储：**数组/链表/字典(哈希表)**都可以。
  - 演示
    ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3mu1hv8a84u0.png)

- 图片解析

  - 其实图片比较容易理解
  - 比如我们要表示和 A 顶点有关联的顶点（边），A 和 B/C/D 有边，那么我们可以通过 A 找到 对应的数组/链表/字典，再取出其中的内容就可以啦。

- 邻接表的问题
  - 邻接表计算**“出度”**是比较简单的（出度：指向别人的数量, 入度: 指向自己的数量）
  - 邻接表如果需要计算有向图的**“入度”**，那么是一件非常麻烦的事情。
  - 它必须构造一个**“逆邻接表”**，才能有效的计算“入度”。而邻接矩阵会非常简单。

## 图的封装

在实现过程中采用**邻接表**的方式来表示边，使用**字典类**来存储邻接表。

### 创建图类

- 先来创建 Graph 类，定义了两个属性：
  - `vertexes` 用于存储所有的顶点，使用一个数组来保存。
  - `edges` 用于存储所有的边，使用一个字典来保存。

```js
// 封装图类
function Graph() {
    // 属性：顶点（数组）/边（字典）
    this.vertexs = [] // 顶点
    this.edges = new Dictionary() //边
}
```

### 添加方法

![image-20200303235132868](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/3.png)

创建一个数组对象vertexes存储图的顶点；创建一个字典对象edges存储图的边，其中key为顶点，value为存储key顶点相邻顶点的数组。

- 添加顶点：可以向图中添加一些顶点。
  - 将添加的顶点放入到数组中。
  - 另外，给该顶点创建一个数组`[]`，该数组用于存储顶点连接的所有的边.（回顾邻接表的实现方式）

```js
// 1.添加顶点
Graph.prototype.addVertex = function (v) {
    this.vertexs.push(v)
    this.edges.set(v, []) // 将边添加到字典中，新增的顶点作为键，对应的值为一个存储边的空数组
}
```

- 添加边：可以指定顶点和顶点之间的边。
  - 添加边需要传入两个顶点，因为边是两个顶点之间的边，边不可能单独存在。
  - 根据顶点 v 1取出对应的数组，将 v2 加入到它的数组中。
  - 根据顶点 v2 取出对应的数组，将 v 1加入到它的数组中。
  - 因为这里实现的是无向图，所以边是可以双向的。

```js
// 2.添加边
Graph.prototype.addEdge = function (v1, v2) { // 传入两个顶点为它们添加边
    this.edges.get(v1).push(v2) // 取出字典对象edges中存储边的数组，并添加关联顶点
    this.edges.get(v2).push(v1) // 表示的是无向图，故要添加互相指向的两条边
}
```

### 转换为字符串输出

toString ()方法：为了能够正确的显示图的结果，就是拿出二维数组的每一项。即实现以邻接表的形式输出图中各顶点。

```js
// 实现toSring()方法
Graph.prototype.toString = function () {
    // 1.定义字符串，保存最终的结果
    let resultSring = ""

    // 2.遍历所有的顶点以及顶点对应的边
    for (let i = 0; i < this.vertexes.length; i++) {
        // 遍历所有顶点
        resultSring += this.vertexes[i] + '->'
        // 先把顶点对应的边取出来以便后面使用
        let vEdges = this.edges.get(this.vertexes[i])
        // 遍历字典中每个顶点对应的数组
        for (let j = 0; j < vEdges.length; i++) {
            resultSring += vEdges[j] + ' '
        }
        resultString += '\n'
    }
    return resultString
}
```

### 测试代码

```js
// 测试代码
// 1.创建图结构
let g = new Graph()

// 2.添加顶点
let myVerttexes = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I']
for (let i = 0; i < myVertexes.length; i++) {
    g.addVertex(myVerttexes[i])
}

//3.添加边
g.addEdge('A', 'B')
g.addEdge('A', 'C')
g.addEdge('A', 'D')
g.addEdge('C', 'D')
g.addEdge('C', 'G')
g.addEdge('D', 'G')
g.addEdge('D', 'H')
g.addEdge('B', 'E')
g.addEdge('B', 'F')
g.addEdge('E', 'I')

console.log(g)
```

![image-20200303233737451](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/4.png)

## 图的遍历

和其他数据结构一样，需要通过某种算法来遍历图结构中每一个数据。这样可以保证，在我们需要时，通过这种算法来访问某个顶点的数据以及它对应的边。

### 遍历的方式

- 图的遍历思想
  图的遍历算法的思想在于必须访问每个第一次访问的节点，并且追踪有哪些顶点还没有被访问到。

- 有两种算法可以对图进行遍历

  - **广度优先搜索(Breadth-First Search, 简称 BFS)**
  - **深度优先搜索(Depth-First Search, 简称 DFS)**
  - 两种遍历算法，都需要明确指定**第一个被访问的顶点**。

- 遍历的注意点

  - 完全探索一个顶点要求我们便查看该顶点的每一条边。
  - 对于每一条所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。
  - 为了保证算法的效率：**每个顶点至多访问两次**。

- 两种算法的思想

  - **BFS 基于队列，入队列的顶点先被探索。**
  - **DFS 基于栈**，通过将顶点存入栈中，顶点是沿着路径被探索的，存在新的相邻顶点就去访问。

- 为了记录顶点是否被访问过，我们使用三种颜色来反应它们的状态。(或者两种颜色也可以)
  - **白色**表示该顶点还没有被访问.
  - **灰色**表示该顶点被访问过, 但并未被探索过.
  - **黑色**表示该顶点被访问过且被完全探索过.
  - 初始化颜色代码

```js
// 初始化顶点的颜色
Graph.prototype.initializeColor = function(){
    let colors = []
    for (let i = 0; i < this.vertexes.length; i++) {
        colors[this.vertexes[i]] = "white"
    }
    return colors
}
```

### 广度优先搜索(BFS)

- 广度优先搜索算法的思路
  广度优先算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是**先宽后深**的访问顶点。
- 图解 BFS
  ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.3vz7fx7tgvs0.png)
- 广度优先搜索的实现

  1. 创建一个队列 Q
  2. 将 v 标注为被发现的(灰色), 并将 v 将入队列 Q
  3. 如果 Q 非空, 执行下面的步骤：
     - 将 v 从 Q 中取出队列
     - 将 v 标注为被发现的灰色
     - 将 v 所有的未被访问过的邻接点（白色），加入到队列中
     - 将 v 标志为黑色

**代码实现：**

```js
// 实现广度优先搜索（BFS）
Graph.prototype.bfs = function (firstV, handler) {
    // 1.初始化颜色
    let colors = this.initializeColor()

    // 2.创建队列
    let queue = new Queue()

    // 3.将顶点加入到队列中
    queue.enqueue(firstV)

    // 4.循环从队列中取出元素，队列为空才停止
    while (!queue.isEmpty()) {
        // 4.1 从队列中取出一个顶点
        let v = queue.dequeue()

        // 4.2 从字典对象edges中获取和该顶点相邻的其他顶点组成的数组
        let vNeighbours = this.edges.get(v)

        // 4.3 将v的颜色设置为灰色
        colors[v] = 'gray'

        // 4.4 遍历v所有相邻的顶点vNeighbours,并且加入队列中
        // 这一步是完成bfs的关键，依赖队列的先进先出的特点。
        for (let i = 0; i < vNeighbours.length; i++) {
            let a = vNeighbours[i];
            //判断相邻顶点是否被探测过，被探测过则不加入队列中；并且加入队列后变为灰色，表示被探测过
            if (colors[a] == 'white') {
                colors[a] = 'gray'
                queue.enqueue(a)
            }
        }
        // 4.5 访问顶点
        handler(v)

        // 4.6 顶点v所有白色的相邻顶点都加入队列后，将顶点v设置为黑色。此时黑色顶点v位于队列最前面，进入下一次while循环时会被取出
        colors[v] = 'black'
    }
}
```

**过程详解：**

下为指定的第一个顶点为A时的遍历过程：

- 如 a 图所示，将在字典edges中取出的与A相邻的且未被访问过的白色顶点B、C、D放入队列que中并变为灰色，随后将A变为黑色并移出队列；
- 接着，如图 b 所示，将在字典edges中取出的与B相邻的且未被访问过的白色顶点E、F放入队列que中并变为灰色，随后将B变为黑色并移出队列；

![image-20200306144336380](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/6.png)

- 如 c 图所示，将在字典edges中取出的与C相邻的且未被访问过的白色顶点G（A，D也相邻不过已变为灰色，所以不加入队列）放入队列que中并变为灰色，随后将C变为黑色并移出队列；
- 接着，如图 d 所示，将在字典edges中取出的与D相邻的且未被访问过的白色顶点H放入队列que中并变为灰色，随后将D变为黑色并移出队列。

![image-20200306144427242](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/7.png)

如此循环直到队列中元素为0，即所有顶点都变黑并移出队列后才停止，此时图中顶点已被全部遍历。

**测试代码**

```js
// 5.调用广度优先算法
let result = ""
g.bfs(g.vertexes[0], function (v) {
    result += v + "-"
})
console.log(result);    // A-B-C-D-E-F-G-H-I-
// 广度优先搜索的顺序不重复地遍历了所有顶点
```

### 深度优先搜索(DFS)

深度优先搜索的思路：

- 深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径知道这条路径最后被访问了。
- 接着原路回退并探索下一条路径。
- 图解 DFS
  ![image](https://cdn.jsdelivr.net/gh/XPoet/image-hosting@master/JavaScript-数据结构与算法/image.1bjimck65r8g.png)

**实现思路：**

- 可以使用**栈**结构来实现深度优先搜索算法；
- 深度优先搜索算法的遍历顺序与二叉搜索树中的先序遍历较为相似，同样可以使用**递归**来实现（递归的本质就是**函数栈**的调用）。

基于递归实现深度优先搜索算法：定义dfs方法用于调用递归方法dfsVisit，定义dfsVisit方法用于递归访问图中的各个顶点。

在dfs方法中：

- 首先，调用initializeColor方法将所有顶点初始化为白色；
- 然后，调用dfsVisit方法遍历图的顶点；

在dfsVisit方法中：

- 首先，将传入的指定节点v标注为**灰色**；
- 接着，处理顶点V；
- 然后，访问V的相邻顶点；
- 最后，将顶点v标注为黑色；

**代码实现：**

```js
// 深度优先搜索（DFS）
Graph.prototype.dfs = function (firstV, handler) {
    // 1.初始化颜色
    let colors = this.initializeColor()

    // 2.从某个顶点依次递归访问
    this.dfsVisit(firstV, colors, handler)
}

//为了方便递归调用，封装访问顶点的函数，传入三个参数分别表示：指定的第一个顶点、颜色、处理函数
Graph.prototype.dfsVisit = function (v, colors, handler) {
    // 1.将颜色设置为灰色
    colors[v] = 'gray'

    // 2.处理v顶点
    handler(v)

    // 3.访问v的相邻顶点
    let vNeighbours = this.edges.get(v)
    for (let i = 0; i < vNeighbours.length; i++) {
        let e = vNeighbours[i]
        //判断相邻顶点是否为白色，若为白色，递归调用函数继续访问
        if (colors[e] == 'white') {
            this.dfsVisit(e, colors, handler)
        }
    }

    // 4.将v设置为黑色
    colors[v] = 'baleck'
}
```

**过程详解：**

这里主要解释一下代码中的第3步操作：访问指定顶点的相邻顶点。

- 以指定顶点A为例，先从储存顶点及其对应相邻顶点的字典对象edges中取出由顶点A的相邻顶点组成的数组：

![image-20200304155916036](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/10.png)

- **第一步**：A顶点变为灰色，随后进入第一个for循环，遍历A白色的相邻顶点：B、C、D；在该for循环的第1次循环中（执行B），B顶点满足：colors == "white"，触发递归，重新调用该方法；
- **第二步**：B顶点变为灰色，随后进入第二个for循环，遍历B白色的相邻顶点：E、F；在该for循环的第1次循环中（执行E），E顶点满足：colors == "white"，触发递归，重新调用该方法；
- **第三步**：E顶点变为灰色，随后进入第三个for循环，遍历E白色的相邻顶点：I；在该for循环的第1次循环中（执行I），I顶点满足：colors == "white"，触发递归，重新调用该方法；
- **第四步**：I顶点变为灰色，随后进入第四个for循环，由于顶点I的相邻顶点E不满足：colors == "white"，停止递归调用。过程如下图所示：

![image-20200304160536187](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/11.png)

- **第五步**：递归结束后一路向上返回，首先回到第三个for循环中继续执行其中的第2、3...次循环，每次循环的执行过程与上面的同理，直到递归再次结束后，再返回到第二个for循环中继续执行其中的第2、3...次循环....以此类推直到将图的所有顶点访问完为止。

下图为遍历图中各顶点的完整过程：

- **发现**表示访问了该顶点，状态变为**灰色**；
- **探索**表示既访问了该顶点，也访问了该顶点的全部相邻顶点，状态变为**黑色**；
- 由于在顶点变为灰色后就调用了处理函数handler，所以handler方法的输出顺序为发现顶点的顺序即：A、B、E、I、F、C、D、G、H 。

![image-20200304154745646](https://gitee.com/ahuntsun/BlogImgs/raw/master/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%9B%BE/12.png)

**测试代码：**

```js
// 6.测试dfs
let result1 = ""
g.dfs(g.vertexes[0], function (v) {
    result1 += v + "--"
})
console.log(result1); // A--B--E--I--F--C--D--G--H--
```

